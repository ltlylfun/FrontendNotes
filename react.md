### React state 和 props 区别是什么 ?

State:

- 定义：state 是组件内部管理的状态数据。
- 用途：用于存储和管理组件内部的动态数据，这些数据可能会在组件生命周期内发生变化。
- 修改方式：只能通过 this.setState 在类组件中或 useState 钩子在函数组件中进行修改。

Props:

- 定义：props 是组件从父组件接收的数据。
- 用途：用于将数据从父组件传递到子组件，子组件可以使用这些数据进行渲染。
- 修改方式：props 是只读的，不能在子组件中修改。

### 什么是 Redux？

Redux 是一个用于 JavaScript 应用程序中的状态管理库，通常与 React 一起使用，但也可以与其他框架或库结合使用。Redux 的主要目的是帮助开发者管理和维持应用程序的状态，使得在复杂应用中状态的变化更可预测和可控。

### 如何在 React 中使用样式？

1. 内联样式 (Inline Styles)
   React 支持在 JSX 中直接使用内联样式。内联样式使用对象语法，键是驼峰命名的 CSS 属性名，值是字符串或数字。

```jsx
import React from "react";

function App() {
  const divStyle = {
    color: "blue",
    backgroundColor: "lightgray",
    padding: "10px",
    borderRadius: "5px",
  };

  return <div style={divStyle}>这是一个有样式的 div</div>;
}

export default App;
```

2. CSS 样式表 (CSS Stylesheets)
   可以像传统 HTML 一样使用外部 CSS 文件，并通过 className 属性来应用样式。

```jsx
// App.js
import React from "react";
import "./App.css"; // 引入 CSS 文件

function App() {
  return <div className="container">这是一个有样式的 div</div>;
}

export default App;
```

```CSS
/* App.css */
.container {
  color: blue;
  background-color: lightgray;
  padding: 10px;
  border-radius: 5px;
}
```

3. CSS 模块 (CSS Modules)
   CSS 模块允许你将 CSS 样式限定在特定组件内，避免全局命名冲突。CSS 模块文件通常以 .module.css 结尾。

```jsx
// App.js
import React from "react";
import styles from "./App.module.css"; // 引入 CSS 模块

function App() {
  return <div className={styles.container}>这是一个有样式的 div</div>;
}

export default App;
```

```CSS
/* App.module.css */
.container {
  color: blue;
  background-color: lightgray;
  padding: 10px;
  border-radius: 5px;
}
```

4. Tailwind CSS
   使用 Tailwind CSS，可以通过类名快速应用样式。

```
function App() {
  return (
    <div className="text-blue-500 bg-gray-200 p-5">
      Hello, World!
    </div>
  );
}
```

### 简述 React 有什么特点？

1. **组件化**

   - **定义**：React 基于组件来构建应用程序。组件是可以独立使用和复用的 UI 单元。
   - **优点**：组件化使得代码更容易维护、复用和测试。

2. **虚拟 DOM (Virtual DOM)**

   - **定义**：React 使用虚拟 DOM 来提高性能。虚拟 DOM 是 React 在内存中维护的一份 DOM 结构的副本。
   - **优点**：当状态发生变化时，React 会先更新虚拟 DOM，然后将其与真实 DOM 进行比较，仅更新必要的部分，从而提高了性能。

3. **单向数据流**

   - **定义**：React 中的数据流是单向的，从父组件流向子组件。
   - **优点**：单向数据流使得数据管理更加清晰和可预测，易于调试和维护。

4. **声明式编程**

   - **定义**：React 采用声明式编程风格，开发者只需描述 UI 应该呈现的状态，而不需要手动操作 DOM。
   - **优点**：声明式编程使得代码更简洁、易于理解和维护。

5. **JSX 语法**

   - **定义**：JSX 是一种 JavaScript 的语法扩展，允许在 JavaScript 中编写类似 HTML 的代码。
   - **优点**：JSX 使得组件的结构更加直观，代码更加清晰。

6. **强大的社区和生态系统**

   - **定义**：React 由 Facebook 维护，并且有一个庞大的开发者社区和丰富的生态系统。
   - **优点**：丰富的第三方库和工具可以帮助开发者更高效地构建应用。

7. **灵活性**

   - **定义**：React 只关注视图层，可以与其他库或框架搭配使用，如 Redux、React Router 等。
   - **优点**：开发者可以根据需要自由选择技术栈，构建灵活的应用架构。

8. **React Hooks**
   - **定义**：React Hooks 是 React 16.8 引入的新特性，让函数组件也能使用状态和生命周期等特性。
   - **优点**：Hooks 简化了组件逻辑，使代码更加简洁和可复用。

### React setState 调用之后发生了什么？是同步还是异步？

1. **异步特性解释**

   - 当你调用 `setState`，React 会将状态更新请求放入队列中，并在稍后的某个时间点进行批量更新。这种异步处理方式可以减少重新渲染的次数，从而提高性能。

2. **具体过程**
   - **状态更新请求加入队列**：`setState` 被调用时，React 将状态更新请求放入队列中，而不是立即更新状态。
   - **批量处理**：在 React 的事件处理机制或者生命周期方法结束之后，React 会检查队列中的状态更新请求，并进行批量处理。这意味着多个 `setState` 调用可能会被合并成一次更新。
   - **重新渲染**：状态更新后，React 重新计算虚拟 DOM，并将变化应用到真实 DOM 上，触发组件的重新渲染。

### React 类组件和函数组件之间的区别是什么？

1. **定义方式**

   - **类组件**：使用类语法。
   - **函数组件**：使用函数语法。

2. **状态管理**

   - **类组件**：使用 `this.state` 和 `this.setState`。
   - **函数组件**：使用 `useState` Hook。

3. **生命周期方法**

   - **类组件**：有一系列生命周期方法。
   - **函数组件**：使用 `useEffect` Hook。

4. **代码简洁性**

   - **类组件**：通常代码较多。
   - **函数组件**：通常更简洁，代码更少。

5. **性能**
   - **类组件**：在某些情况下可能不如函数组件高效。
   - **函数组件**：在某些情况下可能更高效。

### 父子组件的通信方式？

1. **通过 props 传递数据**

   - 适用于简单的父子组件通信。

2. **通过回调函数传递数据**

   - 适用于子组件向父组件传递数据。

3. **使用 Context**

   - 适用于需要在组件树中共享数据的情况。

4. **使用 Redux 或其他状态管理库**
   - 适用于更复杂的应用，提供全局状态管理。

### 简述虚拟 DOM 的概念和机制 ？

**虚拟 DOM (Virtual DOM)** 是一种编程概念，用于提高 web 应用的性能和开发效率。它是实际 DOM 的抽象表示，用纯 JavaScript 对象实现。虚拟 DOM 描述了 UI 的结构和状态，与真实 DOM 相比，更新操作更快、更高效。

### 虚拟 DOM 的机制

虚拟 DOM 的工作机制主要包括以下几个步骤：

1. **创建虚拟 DOM**：

   - React 用 JavaScript 对象来表示组件的结构和状态，这些对象统称为虚拟 DOM。
   - 每次组件状态变化时，React 都会创建一个新的虚拟 DOM。

2. **比较虚拟 DOM（Diffing）**：

   - 当状态或属性发生变化时，React 会生成新的虚拟 DOM 树。
   - React 使用一种高效的算法（Diffing 算法）比较新旧虚拟 DOM 树，找出变化的部分。

3. **更新真实 DOM（Reconciliation）**：
   - React 根据比较结果，仅对真实 DOM 中需要更新的部分进行修改，而不是重新渲染整个页面。
   - 这种部分更新的方式大大提高了性能，减少了浏览器的重绘和重排。

### 解释为什么调用 setState 而不是直接改变 state？

1. **确保状态更新的正确性**

   - `setState` 和 `useState` 的更新函数确保状态更新是正确的，特别是在异步更新的情况下。

2. **触发重新渲染**

   - 状态更新后会触发组件重新渲染，确保 UI 根据最新状态进行更新。

3. **批量更新和性能优化**

   - React 会对多次状态更新进行批量处理，提高性能。

4. **保持状态管理的一致性**
   - 保证状态管理的一致性和可预测性，特别是在复杂应用中。

### 请简述 React 生命周期调用方法的顺序 ？

```
挂载: constructor -> getDerivedStateFromProps -> render -> componentDidMount
更新: getDerivedStateFromProps -> shouldComponentUpdate -> render -> getSnapshotBeforeUpdate -> componentDidUpdate
卸载: componentWillUnmount
```

### React 和 ReactDOM 有什么区别？

使用 React 来定义和创建组件，利用其核心功能。

使用 ReactDOM 来将这些组件渲染到 Web 页面的浏览器 DOM 中。

### react-dom 包有什么用？

- 渲染组件

使用 `ReactDOM.render` 将 React 组件渲染到 DOM 中。

- 创建门户

使用 `ReactDOM.createPortal` 在 DOM 的其他节点中渲染组件。

- 服务端渲染

使用 `react-dom/server` 模块在服务端渲染 React 组件。

- 测试

用于模拟组件渲染和交互测试。

通过使用 `react-dom`，开发者可以将 React 组件的虚拟 DOM 树与实际的浏览器 DOM 进行连接，实现高效、灵活的用户界面更新和渲染。

### React 必须使用 JSX 吗？

React 并不强制使用 JSX，但推荐使用它来提高代码的可读性和开发效率。如果你不想使用 JSX，可以直接使用 React.createElement 来创建 React 组件。选择哪种方式取决于你的项目需求和个人偏好。

### React 组件命名推荐的方式是哪个？

- PascalCase

每个单词的首字母大写，无分隔符。

- 单一职责原则

组件名称应反映其功能或用途。

- 避免缩写

尽量使用完整的单词，以提高代码的可读性。

### 为什么 Redux state 函数被称为 Reducer？

### 为什么 React 使用 className 而不是 class 属性？

### 什么是 Flux？

Flux 的单向数据流模型使得应用的状态管理更加清晰和可预测

1. **用户交互或其他事件** 触发 **动作**。
2. **动作** 被分发到 **分发器**。
3. **分发器** 调用所有注册的 **存储** 中的处理函数。
4. **存储** 更新状态并发出变化事件。
5. **视图** 监听 **存储** 的变化事件，重新获取数据并重新渲染。

总结

Flux 是一种架构模式，特别适用于使用 React 构建的复杂客户端应用。它通过单向数据流的方式，使得应用的状态管理更加清晰、可预测。Flux 的核心部分包括 **动作**、**分发器**、**存储** 和 **视图**，每个部分各司其职，共同构成一个高效的数据流管理体系。

### 什么是 ReactDOMServer？

ReactDOMServer

`ReactDOMServer` 允许你在服务器上渲染 React 组件，并将生成的 HTML 发送到客户端。这不仅提高了页面加载速度，还改善了 SEO。通过结合客户端的 `ReactDOM.hydrate` 方法，你可以在初始加载后接管服务器渲染的内容，实现无缝的客户端交互体验。

### 什么是 Fragment？

Fragment 是 React 提供的一个方便的工具，用于包裹一组子元素而不会在 DOM 中添加额外的节点。它可以通过 React.Fragment 或简写形式 <>...</> 来使用，主要用于避免不必要的 DOM 元素，提高性能，并保持 HTML 结构的语义化。

### 什么是无状态组件？

无状态组件是通过函数定义的简单组件，只负责接收 props 并渲染 UI。它们没有内部状态和生命周期方法，非常适合用于渲染静态内容或展示数据。通过 React Hooks，即使是函数组件也可以管理状态和副作用，使得函数组件更加强大和灵活。

### 什么是有状态组件？

有状态组件在 React 中通过管理内部状态来实现动态和交互式的用户界面。它们可以使用类组件或结合 Hooks 的函数组件来实现，适合处理需要内部状态管理和复杂逻辑的情况。无状态组件则更适合用于渲染静态内容或展示数据的简单组件。

### 有状态组件 vs 无状态组件

#### 有状态组件

- 维护和管理自己的内部状态。
- 可以使用生命周期方法（类组件）。
- 适合处理复杂逻辑和交互的组件。

#### 无状态组件（Stateless Component）

- 不维护内部状态。
- 只接收 props 并渲染 UI。
- 更简单和轻量，适合只负责展示数据的组件。

### 简述 React store 的概念 ？

在 React 中，"store" 通常指的是一个集中式的状态管理机制，用于管理组件的共享状态。虽然 React 本身没有内置的 store 概念，但在很多状态管理库（如 Redux、MobX、Recoil）中，store 这个术语非常常见。

### 简述点(…)在 React 的作用 ？

在 React 中，点（...）符号主要用作展开语法（spread syntax）和剩余参数（rest parameters）。

### 解释 React 中 render() 的目的和作用 ？

### props 的变动，是否会引起 state hook 中数据的变动？

在 React 中，props 和 state 是两个独立的概念。props 是从父组件传递给子组件的数据，而 state 是组件内部管理的数据。通常情况下，props 的变动不会直接引起 state hook 中数据的变动，除非你在组件中显式地处理这种关系。

### React Context 和 React Redux 有什么区别？

React Context

- 内置于 React，不需要额外依赖。
- 适用于简单的状态共享和全局配置。
- 在频繁更新场景下可能存在性能问题。

React Redux

- 需要额外安装 `redux` 和 `react-redux`。
- 适用于复杂的大型应用，提供单一数据源和可预测的状态管理。
- 支持中间件和强大的调试工具，适合处理复杂的状态管理需求。

### React diff 算法的原理是什么？

React 的 diff 算法通过层级比较、同类节点比较和唯一标识（key）来高效地计算新旧虚拟 DOM 之间的差异。这个算法使得 React 能够最小化实际 DOM 的操作，从而提高性能和响应速度。理解这些原理有助于更好地优化和使用 React 构建高性能的应用。

### React Hooks 和生命周期的关系？

Hooks 提供了在函数组件中使用状态和副作用的能力。

useEffect Hook 可以覆盖类组件的生命周期方法，通过适当的执行逻辑处理组件的不同状态。

Hooks 更加简洁，且易于组合和重用，使代码更具有可读性和可维护性。

### React 与 React Native 有何不同？

运行环境：

- **React** 运行在浏览器中，用于构建网页应用。
- **React Native** 运行在移动设备上，用于构建移动应用。

UI 组件：

- **React** 使用 HTML 标签和自定义的 React 组件。
- **React Native** 使用原生组件（如 `<View>`、`<Text>`）和自定义的 React Native 组件。

样式：

- **React** 使用 CSS 或 CSS-in-JS 库来定义样式。
- **React Native** 使用内联样式对象或 `StyleSheet` 来定义样式。

目标平台：

- **React** 主要用于构建跨浏览器的网页应用。
- **React Native** 主要用于构建跨平台的移动应用（支持 iOS 和 Android）。

### React 中的命令式和声明式有什么区别？

React 中的声明式编程

React 鼓励使用声明式编程风格，因为它简化了代码的编写和维护。通过声明式编程，你只需描述组件的最终状态，而不需要关心如何一步步地达到这个状态。React 会根据状态和 props 的变化自动更新 UI。

声明式编程：

- 描述“做什么”。
- 代码更简洁、易读。
- React 会根据状态变化自动更新 UI。

命令式编程：

- 描述“怎么做”。
- 代码更详细、复杂。
- 需要手动处理 DOM 操作和状态管理。

在 React 中，使用声明式编程可以让代码更直观、更易于维护，同时充分利用 React 的自动化更新机制。

### React 组件中怎么做事件代理？它的原理是什么？

在 React 中，事件代理是一种优化性能的技术，通过将事件监听器添加到父元素上来处理其子元素的事件，而不是为每个子元素添加单独的事件监听器。这可以减少内存消耗和提高应用的性能。

事件代理的原理

事件代理的原理基于事件冒泡（Event Bubbling），即事件从最深的元素开始触发，逐级向上传播到父元素。通过将事件监听器添加到父元素上，可以捕获并处理所有子元素的事件。

在 React 中实现事件代理

在 React 中实现事件代理非常简单。你可以在父组件中添加事件监听器，并在事件处理函数中使用事件对象 (event) 来确定具体的目标子元素。

### React 高阶组件是什么，和普通组件有什么区别，适用什么场景

高阶组件（HOC）是一种用于重用组件逻辑的模式，通过接收一个组件并返回一个新的组件，实现逻辑复用和代码抽象。与普通组件不同，高阶组件侧重于增强和修改组件的行为，适用于逻辑复用、组件增强和代码分离的场景。理解和使用高阶组件可以提高代码的可维护性和复用性。

### React 中 props.children 和 React.Children 的区别

props.children 用于直接访问组件的子元素。

React.Children 提供了一些实用函数，用于操作和处理这些子元素，特别是在需要遍历、计数或转换子元素时非常有用。

### React 中什么是受控组件和非控组件？

受控组件：表单元素的值由组件的 state 管理，React 负责更新和渲染。

非控组件：表单元素的值由 DOM 本身管理，React 只管理监听事件，不存储值。

### React 中发起网络请求应该在哪个生命周期中进行？为什么？

类组件：在 componentDidMount 生命周期方法中发起网络请求。

函数组件：使用 useEffect hook 并传递一个空依赖数组来发起网络请求。

这样做可以确保网络请求只在组件挂载后发起一次，并且组件已经准备好接收和渲染数据。

### React 中怎么检验 props？验证 props 的目的是什么？

验证 props 的目的：捕捉错误、文档化、提高开发体验。

使用 prop-types：安装 `prop-types` 库，并在组件中定义 `propTypes` 和 `defaultProps`。

常用类型：了解 `prop-types` 提供的各种类型和复合类型，以便更好地进行 props 验证。

通过使用 `prop-types` 对 props 进行验证，可以提高 React 组件的可靠性和可维护性，帮助开发者在开发过程中及时发现和修正错误。

### React 如何判断什么时候重新渲染组件？

状态（state）变化、属性（props）变化 和 上下文（Context）变化 是触发组件重新渲染的主要因素。

React 使用虚拟 DOM 和调和过程来高效地进行重新渲染。

可以通过 `shouldComponentUpdate`、`React.memo`、`useMemo` 和 `useCallback` 等方法来优化组件的重新渲染。

### React 如何获取组件对应的 DOM 元素？

在函数组件中，可以使用 useRef Hook 创建 ref，并将其附加到 DOM 元素上。

### React 的严格模式如何使用，有什么用处？

使用严格模式：可以在应用的入口文件或组件树的一部分包裹 `StrictMode` 组件。

作用：帮助识别不安全的生命周期方法、检测意外的副作用、检测过时的字符串 ref API、检测遗留的 context API 和检测意外的 `findDOMNode` 使用。

开发模式：严格模式仅在开发模式下生效，不会影响生产环境。

### React 的事件和普通的 HTML 事件有什么不同？

事件绑定方式：

- **React**：在 React 中，事件处理函数是在 JSX 中通过属性来绑定的。这些属性的命名遵循 camelCase（驼峰命名法）。
- **HTML**：在普通的 HTML 中，事件处理函数可以直接在 HTML 属性中通过字符串绑定，属性名通常是小写。

事件命名方式：

- **React**：事件处理函数的属性名使用 camelCase（驼峰命名法）。
- **HTML**：事件处理函数的属性名使用小写。

事件对象：

- **React**：React 的事件对象是合成事件（SyntheticEvent），它是跨浏览器兼容的封装，基于 W3C 规范。合成事件会自动进行事件池化，因此事件处理函数中的事件对象在异步调用中可能会失效。
- **HTML**：普通的 HTML 事件对象是原生的，依赖于浏览器的实现。

事件处理函数的绑定：

- **React**：在类组件中，事件处理函数通常需要手动绑定 `this`，或者使用箭头函数来保持 `this` 的上下文。
- **HTML**：普通的 HTML 事件处理函数不需要显式绑定 `this`。

### React 的状态提升是什么？使用场景有哪些？

多个组件需要共享数据：比如有两个输入框组件需要同步更新某个值，把状态放到它们共同的父组件中，就可以确保输入框显示相同的值。

兄弟组件之间信息交互：当兄弟组件之间需要通信或者协调状态时，可以将共同的状态上升到父组件，父组件再将数据通过 props 传递给每个子组件。

复杂表单或交互：在一些需要多个组件协同工作的场景，通过状态提升可以减少各组件之间的耦合，统一管理数据变化。

需要集中管理并验证数据：当需要统一做数据验证或业务逻辑处理时，将所有状态集中在父组件管理会更好。

### state 和 props 触发更新的生命周期分别有什么区别？

- **state 改变**：由组件内部事件触发，通常用于处理局部交互和内部业务逻辑；更新时侧重于利用本地状态驱动视图。
- **props 改变**：由父组件重新渲染或传入新的数据引起，组件通过对比前后 props 来决定是否需要更新；这时组件可能需要根据新 props 进行状态同步或响应一些外部变化。

### 为什么 Fragments 比 Div 更好？

- 避免生成额外的 DOM 节点

使用 Fragment 可以将多个子组件或元素包裹在一起，但不会真正在 DOM 中生成额外的 wrapper 元素。这可以减少不必要的嵌套，优化渲染性能，并且让生成的 HTML 结构更加清洁和语义化。

- 改善样式管理

额外的 `div` 可能会干扰 CSS 布局和样式，使用 Fragment 可以避免这种情况，因为它不会在渲染时生成任何额外的 DOM 节点，从而使得样式的控制更加精确。

- 更加符合语义

在某些情况下，使用 `div` 作为容器并没有实际的语义意义，而 Fragment 仅仅作为一个虚拟容器，专门用于组合子元素，无需增加额外的语义含义。

### 为什么在本地开发时，组件会渲染两次？

在本地开发环境中，组件可能会渲染两次，主要原因是 React 的 Strict Mode。在开发模式下，React 的 Strict Mode 用于帮助开发者发现意外的副作用和不安全的生命周期方法，因此会对组件进行额外的渲染检查。这些额外的渲染（例如初始化阶段 render 两次）只会在开发环境中出现，用于捕捉潜在问题，而不会出现在生产环境中。

### 什么是合成事件，与原生事件有什么区别？

跨浏览器兼容性：
Synthetic 事件通过封装浏览器原生事件，确保在不同浏览器中的行为一致。这意味着你在事件处理函数中，无论使用哪个浏览器，都可以依赖相同的 API 和行为。

性能优化（事件池）：
为了提高性能，React 会对 Synthetic 事件进行事件池化（Event Pooling）。在事件处理函数执行完毕后，React 会将 Synthetic 事件对象中的属性全部清空，复用这些对象以减少内存开销。如果你需要在异步代码中使用事件对象的属性，请先调用 event.persist()，这会把事件对象从池中移除，防止其被回收。

统一接口：
Synthetic 事件提供了与原生事件类似的接口（例如 preventDefault()、stopPropagation() 等），但是这些方法的实现和行为经过了 React 的封装，更易于管理和调试。

### 你对“单一事实来源”有什么理解

在 React 中，“单一事实来源”（Single Source of Truth）是指应用中的状态数据应该集中存储在一个地方，而不是分散在多个地方。这种设计理念可以提高数据管理的清晰性和一致性，避免状态的不一致以及减少错误。

### 在 React 中如何防范 XSS 攻击？

利用 React 默认的 HTML 转义机制：
React 会自动对 JSX 中插入的内容进行转义，防止恶意代码直接被注入。例如，当你将用户输入直接渲染到页面时，React 会将尖括号等特殊字符转义，从而使得浏览器不会识别其为 HTML 标签。

避免使用 dangerouslySetInnerHTML（除非你确定内容已安全处理）：
dangerouslySetInnerHTML 可以直接插入 HTML 内容，这会绕过 React 的自动转义机制。如果必须使用，应确保内容已通过诸如 DOMPurify 等库进行严格的消毒。

对第三方内容进行严格过滤：
如果数据来源是用户输入或第三方内容，一定要进行服务端或客户端的消毒处理，防止其中包含恶意脚本。

### 多次执行 useState()，会触发多次更新吗？

在 React 中，多次调用 useState() 本身不会触发更新。useState() 的作用是为组件创建一个状态变量以及对应的更新函数。当你在组件内多次调用 useState() 时，只是创建了多个状态变量，每个状态变量的更新是相互独立的。

至于 state 的更新（即调用相应的更新函数 setState），React 会对这些调用进行批处理（batching）。这种批处理机制意味着如果在同一个事件处理函数中连续多次调用 setState，它们通常会合并为一次更新，从而只触发一次重新渲染。

### 如何解决 props 层级过深的问题

使用 React Context

利用 React 的 Context API，可以直接在任意组件中访问共享状态，而不需要层层传递 props，从而大大简化组件间的数据传递。

使用状态管理库

比如 Redux、MobX 或 Recoil，这些库都提供了全局状态管理解决方案，可以有效避免大量 props 传递。

组合模式和 Render Props

通过组件组合以及 Render Props 模式，可以将功能模块化，减少不必要的 props 层级传递。

### 完整的简述 React 的 diff 过程 ？

#### 整体策略

React 的 diff 算法基于两个前提：

- 同一层级的元素通常比较相似。
- 在列表操作中，通过 key 属性可以高效确定哪些元素被修改、插入或删除。

这些假设使得算法无需进行全树深度比较，从而将复杂度降低到 O(n)。

#### Diff 的基本原则

- 如果两个虚拟 DOM 节点类型不同（例如，一个是 `<div>`，另一个是 `<span>`），React 会认为它们完全不同，会销毁旧的节点及其子树，并直接创建新的节点。
- 如果节点类型相同，则 React 会逐步比较它们的属性（props）以及子节点。在属性层面，只更新那些发生改变的部分；在子节点层面，则采用递归的方式进行比较。

#### 子节点比较

对于子节点的 diff，React 会遍历同一层级的所有节点：

- 如果子节点是普通的文本或元素节点，则直接通过“同类型”比较进行递归 diff。
- 如果是列表（数组）结构，React 会利用每个元素的 key 属性来迅速匹配新旧节点。
  - 如果 key 相同，则认为该节点对应并进行更新。
  - 如果存在 key 的变化（例如元素顺序改变），React 会对比 key 来决定是移动、插入还是删除操作，从而实现最小化更新。

#### 更新过程

在整个 diff 过程中，React 会记录需要对真实 DOM 执行的操作，如更新属性、插入新节点、删除旧节点或移动节点。最后，React 根据这一最小更新集合，一次性地将变更应用到实际 DOM 上，提升性能和响应速度。

#### 总结

React 的 diff 算法利用对节点类型和 key 的假设，尽可能只重绘实际发生变化的部分，避免了全量比对，从而在大型应用中实现高效的界面更新。

### 对 React context 的理解

React Context 是 React 提供的一个用于在组件树中共享数据的机制，可以避免通过 props 层层传递。它非常适用于一些全局数据，比如用户信息、主题设置、语言选择等。

### 对 React SSR 的理解

React Server-Side Rendering（SSR，服务端渲染）是将 React 组件在服务器上渲染为 HTML 字符串，然后发送到客户端的一种技术。与客户端渲染相比，SSR 更加注重首屏加载性能和搜索引擎优化（SEO），以下是对 React SSR 的一些理解：

### 描述 React 中的数据流。

在 React 中，数据流主要遵循 **单向流动（单向数据绑定）** 的原则，这意味着数据总是从父组件流向子组件。以下是一些关键点：

- **父子组件通信**
  - 父组件通过 `props` 向子组件传递数据，子组件只能读取这些 `props`，但不能直接修改。
- **父组件状态更新**
  - 当子组件希望改变父组件的状态时，会通过回调函数（作为 `props` 传入）通知父组件，由父组件来更新状态。
- **状态提升**
  - 在比较复杂的应用中，可能会使用状态提升（lifting state up），将多个子组件共用的状态提升到它们的最近公共父组件中。
- **跨组件数据共享**
  - 对于跨组件的数据共享，可以利用 React Context、Redux、MobX 等状态管理库，在应用的多个层级中传递数据。
- **Hooks 的使用**
  - React 的 Hooks（如 `useState`、`useReducer`、`useContext` 等）提供了一种轻量级且灵活的方式来管理函数组件中的状态和副作用。

这种单向数据流的设计使得整个状态的改变和数据传递路径变得更加清晰、可控，也便于调试和维护代码。

### 简述 React key 是干嘛用的 为什么要加？key 主要是解决哪⼀类问题的？

在 React 中，`key` 是用于标识列表中每个元素的独一无二的标识符，主要用于帮助 React 在更新列表时更高效地定位哪些元素发生了变化。下面几点说明了 `key` 的作用和添加它的原因：

- **防止重渲染错误**  
  使用 `key` 可以让 React 更精确地判断哪些元素需要重新渲染，从而避免因为重新排序或增删列表项而导致的元素复用错误。

- **提高渲染效率**  
  在进行 DOM Diff 算法比对时，`key` 帮助 React 快速定位元素的变化，减少不必要的操作，提高性能。

- **保持组件状态**  
  当列表项有状态时，正确设置 `key` 可以确保在更新列表时，每个组件的状态能够正确保留，而不会由于错误的复用而丢失状态数据。

### 简述 React diff 算法的原理是什么 ？

React 的 Diff 算法是一种优化虚拟 DOM 更新性能的策略，其核心思想是通过合理的比较减少不必要的 DOM 操作。下面是 Diff 算法的基本原理：

1. 同层比较

---

React 仅在同一层级节点之间进行比较。对于不同层级的节点，React 会直接删除旧节点并插入新节点。

2. 唯一 key

---

当渲染列表时，使用唯一的 `key` 属性可以帮助 React 更高效地识别哪些元素发生了变化、添加或删除。相同的 `key` 表示这些元素具有相同的身份，React 在更新时会优先考虑具有相同 `key` 的元素。

3. 元素类型对比

---

- 如果两个元素具有不同的类型，React 会完全摧毁旧的子树并创建新的子树。
- 如果两个元素是相同类型，React 会进一步比较它们的属性和子节点。

4. 递归对比

---

当发现两个相同类型的元素时，React 会比较它们的 `props` 和其他特性：

- 如果 `props` 有所变化，React 会更新这些属性；
- 同时，React 还会递归对比它们的子节点，只有当子节点也发生变化时，才会进行相应更新。

5. 批量更新

---

React 会尽量将多个更新合并为一次 DOM 操作，从而进一步提高性能。

通过这些策略，React 的 Diff 算法显著优化了界面更新的性能，使得 UI 渲染更加高效。

### 简述 React 中的高阶组件运用了什么设计模式 ？

React 中的高阶组件（Higher-Order Component, HOC）运用了装饰器模式（Decorator Pattern）的设计思想。

- 概念说明

高阶组件本质上是一个函数，它接收一个组件作为输入，并返回一个新的组件。通过在原组件外层添加额外的功能或数据，实现对原组件的“包装”，而不改变原组件的内部实现。这种封装技术和装饰器模式类似，通过组合的方式来扩展组件的功能。

- 关键点

1. 装饰和扩展  
   HOC 可以在不修改原组件的情况下为其添加新的功能或属性，就像装饰者（Decorator）在不改变原始对象的情况下为其添加额外行为。

2. 复用逻辑  
   通过使用 HOC，可以将一些通用的逻辑抽取出来，并在多个组件之间共享，从而提高代码的复用性。

3. 分离关注点  
   高阶组件能够将额外的功能与 UI 表现分离，使得组件的职责更加单一和明确。

- 应用场景

HOC 被广泛应用于处理诸如权限控制、数据获取、缓存、性能优化等场景。通过将共用的逻辑封装到 HOC 中，能够有效减少代码重复，同时使得组件更加关注于 UI 的渲染。

- 总结

这种模式很好地体现了“组合优于继承”的理念，同时在 React 中也促进了组件逻辑的清晰分离和复用性提升。

### 简述 React.Children.map 和 js 的 map 有什么区别 ？

#### 处理对象类型

- **React.Children.map**:

  - 专门为处理 React 组件的子元素设计。
  - 能够正确处理 React 元素、数组以及单个元素等多种情况，包括嵌套结构。
  - 可处理 null 和 undefined，从而避免在渲染时出现错误。

- **Array.prototype.map**:
  - 是 JavaScript 原生的数组方法，仅适用于数组。
  - 如果传入的不是数组（例如一个 React 元素），可能会导致错误。

#### 返回值

- **React.Children.map**:

  - 返回的是一个 React 元素集合，适合直接在 JSX 中使用。

- **Array.prototype.map**:
  - 返回的是一个新数组，主要用于处理普通的数组数据，但不一定是可以直接渲染的 React 元素。

#### 性能优化

- **React.Children.map**:

  - 专为 React 特定场景优化，适合高效地处理 React 的虚拟 DOM 结构。
  - 在遍历子元素时，会内部考虑到 React 的更新机制。

- **Array.prototype.map**:
  - 不包含 React 组件更新的优化，主要用于通用的数据处理场景。

### 如何避免在 React 重新绑定实例？

对于函数组件，可以利用 Hooks（如 useCallback）来缓存函数，从而避免在每次渲染时创建新的函数实例。

### React-Router 的 Switch 有什么用？

React Router 中的 Switch 组件主要用于路由匹配的控制，确保在多个 <Route> 中只渲染第一个匹配到的路由。当多个路由规则可以匹配当前的 URL 时，Switch 会从上到下遍历其所有子 <Route> 组件，并只渲染第一个匹配成功的路由，而忽略后续的匹配。这种行为可以防止多个路由同时渲染造成的页面混乱或冲突。

### react-router 里的 Link 标签和 a 标签的区别

使用 React Router 的 Link 组件可以保持单页应用的流畅性和状态管理，避免页面全局刷新；而直接使用 a 标签则会触发浏览器的默认行为，导致页面刷新且可能丢失应用状态。所以在进行内部路由导航时，推荐使用 Link 组件。
